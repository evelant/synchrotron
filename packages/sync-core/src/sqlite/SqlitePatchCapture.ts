import type { SqlClient, SqlError } from "@effect/sql"
import { Effect } from "effect"
import { ClientDbAdapterError } from "../ClientDbAdapter"

const quoteSqliteIdentifier = (identifier: string) =>
	`"${identifier.replaceAll('"', '""').replaceAll(".", '"."')}"`

const sqliteTriggerName = (tableName: string, op: string) => {
	const base = tableName.replaceAll(/[^a-zA-Z0-9_]/g, "_")
	return `sync_patches_${base}_${op}`.slice(0, 60)
}

const createSqlitePatchTriggersForTable = (deps: {
	readonly sql: SqlClient.SqlClient
	readonly dbDialect: "sqlite"
	readonly tableName: string
}): Effect.Effect<void, SqlError.SqlError | ClientDbAdapterError> =>
	Effect.gen(function* () {
		const { sql, dbDialect, tableName } = deps

		// Important SQLite detail: use pragma_table_xinfo so generated columns (like audience_key GENERATED ...)
		// are detected; pragma_table_info can miss them.
		const columns = yield* sql<{ name: string; type: string | null; hidden?: number }>`
			SELECT name, type, hidden FROM pragma_table_xinfo(${tableName})
		`.pipe(
			Effect.catchAll(() =>
				sql<{ name: string; type: string | null }>`
					SELECT name, type FROM pragma_table_info(${tableName})
				`.pipe(Effect.map((rows) => rows.map((r) => ({ ...r, hidden: 0 }))))
			)
		)
		const visibleColumns = columns.filter((c) => (c.hidden ?? 0) !== 1)
		if (columns.length === 0) {
			return yield* Effect.fail(
				new ClientDbAdapterError({
					message: `Cannot install patch triggers: table not found: ${tableName}`,
					tableName,
					expectedDialect: dbDialect
				})
			)
		}

		const columnNames = visibleColumns.map((c) => c.name)
		const booleanColumnNames = new Set(
			visibleColumns.filter((c) => (c.type ?? "").toLowerCase().includes("bool")).map((c) => c.name)
		)
		const hasId = columnNames.some((c) => c.toLowerCase() === "id")
		if (!hasId) {
			return yield* Effect.fail(
				new ClientDbAdapterError({
					message: `Cannot install patch triggers: table "${tableName}" must have an "id" column`,
					tableName,
					columnName: "id",
					expectedDialect: dbDialect
				})
			)
		}

		const hasAudienceKey = columnNames.some((c) => c.toLowerCase() === "audience_key")
		if (!hasAudienceKey) {
			return yield* Effect.fail(
				new ClientDbAdapterError({
					message: `Cannot install patch triggers: table "${tableName}" must have an "audience_key" column (see docs/shared-rows.md)`,
					tableName,
					columnName: "audience_key",
					expectedDialect: dbDialect
				})
			)
		}

		// `audience_key` is used for sync-log visibility filtering; store it on the AMR row and
		// omit it from patches so it can be derived/generated by the app schema.
		const patchColumnNames = columnNames.filter((c) => c.toLowerCase() !== "audience_key")

		const patchNonIdColumns = patchColumnNames.filter((c) => c.toLowerCase() !== "id")

		const tableIdent = quoteSqliteIdentifier(tableName)

		const sqliteJsonValue = (prefix: "NEW" | "OLD", columnName: string) => {
			const columnRef = `${prefix}.${quoteSqliteIdentifier(columnName)}`
			if (!booleanColumnNames.has(columnName)) return columnRef
			return `CASE WHEN ${columnRef} IS NULL THEN NULL WHEN ${columnRef} != 0 THEN json('true') ELSE json('false') END`
		}

		const jsonObjectFor = (prefix: "NEW" | "OLD") => {
			const parts: string[] = []
			for (const col of patchColumnNames) {
				parts.push(`'${col.replaceAll("'", "''")}', ${sqliteJsonValue(prefix, col)}`)
			}
			return `json_object(${parts.join(", ")})`
		}

		const changedCondition =
			patchNonIdColumns.length === 0
				? // Still run when audience_key changes so we can abort (scope moves are not supported).
					`OLD.${quoteSqliteIdentifier("audience_key")} IS NOT NEW.${quoteSqliteIdentifier("audience_key")}`
				: [
						...patchNonIdColumns.map(
							(col) => `OLD.${quoteSqliteIdentifier(col)} IS NOT NEW.${quoteSqliteIdentifier(col)}`
						),
						`OLD.${quoteSqliteIdentifier("audience_key")} IS NOT NEW.${quoteSqliteIdentifier("audience_key")}`
					].join(" OR ")

		const jsonPatchChain = (prefix: "NEW" | "OLD") => {
			let expr = `'{}'`
			for (const col of patchNonIdColumns) {
				const colLiteral = col.replaceAll("'", "''")
				const colIdent = quoteSqliteIdentifier(col)
				const valueExpr = sqliteJsonValue(prefix, col)
				expr = `json_patch(${expr}, CASE WHEN OLD.${colIdent} IS NOT NEW.${colIdent} THEN json_object('${colLiteral}', ${valueExpr}) ELSE '{}' END)`
			}
			return expr
		}

		const triggerInsertName = sqliteTriggerName(tableName, "insert")
		const triggerUpdateName = sqliteTriggerName(tableName, "update")
		const triggerDeleteName = sqliteTriggerName(tableName, "delete")

		// TEMP triggers so they can reliably reference TEMP sync_context.
		const insertTriggerSql = `
CREATE TEMP TRIGGER ${quoteSqliteIdentifier(triggerInsertName)}
AFTER INSERT ON ${tableIdent}
WHEN (SELECT disable_tracking FROM sync_context LIMIT 1) = 0
BEGIN
  SELECT
    CASE
      WHEN (SELECT capture_action_record_id FROM sync_context LIMIT 1) IS NULL
        OR (SELECT capture_action_record_id FROM sync_context LIMIT 1) = ''
      THEN RAISE(ABORT, 'sync.capture_action_record_id not set')
    END;

  INSERT INTO action_modified_rows (
    id,
    table_name,
    row_id,
    action_record_id,
    audience_key,
    operation,
    forward_patches,
    reverse_patches,
    sequence
  ) VALUES (
    (SELECT capture_action_record_id FROM sync_context LIMIT 1) || ':' || (SELECT sequence FROM sync_context LIMIT 1),
    '${tableName.replaceAll("'", "''")}',
    NEW.${quoteSqliteIdentifier("id")},
    (SELECT capture_action_record_id FROM sync_context LIMIT 1),
    NEW.${quoteSqliteIdentifier("audience_key")},
    'INSERT',
    ${jsonObjectFor("NEW")},
    '{}',
    (SELECT sequence FROM sync_context LIMIT 1)
  );

  UPDATE sync_context SET sequence = sequence + 1;
END;
`

		const deleteTriggerSql = `
CREATE TEMP TRIGGER ${quoteSqliteIdentifier(triggerDeleteName)}
AFTER DELETE ON ${tableIdent}
WHEN (SELECT disable_tracking FROM sync_context LIMIT 1) = 0
BEGIN
  SELECT
    CASE
      WHEN (SELECT capture_action_record_id FROM sync_context LIMIT 1) IS NULL
        OR (SELECT capture_action_record_id FROM sync_context LIMIT 1) = ''
      THEN RAISE(ABORT, 'sync.capture_action_record_id not set')
    END;

  INSERT INTO action_modified_rows (
    id,
    table_name,
    row_id,
    action_record_id,
    audience_key,
    operation,
    forward_patches,
    reverse_patches,
    sequence
  ) VALUES (
    (SELECT capture_action_record_id FROM sync_context LIMIT 1) || ':' || (SELECT sequence FROM sync_context LIMIT 1),
    '${tableName.replaceAll("'", "''")}',
    OLD.${quoteSqliteIdentifier("id")},
    (SELECT capture_action_record_id FROM sync_context LIMIT 1),
    OLD.${quoteSqliteIdentifier("audience_key")},
    'DELETE',
    '{}',
    ${jsonObjectFor("OLD")},
    (SELECT sequence FROM sync_context LIMIT 1)
  );

  UPDATE sync_context SET sequence = sequence + 1;
END;
`

		const updateTriggerSql = `
CREATE TEMP TRIGGER ${quoteSqliteIdentifier(triggerUpdateName)}
AFTER UPDATE ON ${tableIdent}
WHEN (SELECT disable_tracking FROM sync_context LIMIT 1) = 0
  AND (${changedCondition})
BEGIN
  SELECT
    CASE
      WHEN (SELECT capture_action_record_id FROM sync_context LIMIT 1) IS NULL
        OR (SELECT capture_action_record_id FROM sync_context LIMIT 1) = ''
      THEN RAISE(ABORT, 'sync.capture_action_record_id not set')
    END;

  SELECT
    CASE
      WHEN OLD.${quoteSqliteIdentifier("audience_key")} IS NOT NEW.${quoteSqliteIdentifier("audience_key")}
      THEN RAISE(ABORT, 'audience_key change is not supported; model as DELETE + INSERT')
    END;

  INSERT INTO action_modified_rows (
    id,
    table_name,
    row_id,
    action_record_id,
    audience_key,
    operation,
    forward_patches,
    reverse_patches,
    sequence
  ) VALUES (
    (SELECT capture_action_record_id FROM sync_context LIMIT 1) || ':' || (SELECT sequence FROM sync_context LIMIT 1),
    '${tableName.replaceAll("'", "''")}',
    NEW.${quoteSqliteIdentifier("id")},
    (SELECT capture_action_record_id FROM sync_context LIMIT 1),
    NEW.${quoteSqliteIdentifier("audience_key")},
    'UPDATE',
    ${jsonPatchChain("NEW")},
    ${jsonPatchChain("OLD")},
    (SELECT sequence FROM sync_context LIMIT 1)
  );

  UPDATE sync_context SET sequence = sequence + 1;
END;
`

		yield* sql.unsafe(`DROP TRIGGER IF EXISTS ${quoteSqliteIdentifier(triggerInsertName)}`).raw
		yield* sql.unsafe(insertTriggerSql).raw

		yield* sql.unsafe(`DROP TRIGGER IF EXISTS ${quoteSqliteIdentifier(triggerUpdateName)}`).raw
		yield* sql.unsafe(updateTriggerSql).raw

		yield* sql.unsafe(`DROP TRIGGER IF EXISTS ${quoteSqliteIdentifier(triggerDeleteName)}`).raw
		yield* sql.unsafe(deleteTriggerSql).raw

		yield* Effect.logInfo("clientDbAdapter.installPatchCapture.table", {
			dbDialect,
			tableName,
			triggers: {
				insert: triggerInsertName,
				update: triggerUpdateName,
				delete: triggerDeleteName
			}
		})
	})

export const installSqlitePatchCapture = (deps: {
	readonly sql: SqlClient.SqlClient
	readonly dbDialect: "sqlite"
	readonly tableNames: ReadonlyArray<string>
}): Effect.Effect<void, SqlError.SqlError | ClientDbAdapterError> =>
	Effect.all(
		Array.from(deps.tableNames).map((tableName) =>
			createSqlitePatchTriggersForTable({ sql: deps.sql, dbDialect: deps.dbDialect, tableName })
		),
		{ concurrency: 1 }
	).pipe(Effect.asVoid)
