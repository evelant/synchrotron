-- File: packages/sync-core/src/db/sql/patch/deterministic_id_trigger.sql

-- Ensure the uuid-ossp extension is available
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Function to generate deterministic UUIDv5 based on action context and row content
CREATE OR REPLACE FUNCTION generate_deterministic_id()
RETURNS TRIGGER AS $$
DECLARE
    v_action_record_id TEXT;
    v_collision_map JSONB;
    v_counter INT;
    v_content_string TEXT;
    v_content_hash TEXT;
    v_name_string TEXT;
    v_new_id UUID;
    v_record_jsonb JSONB;
BEGIN
    -- Check if sync.disable_trigger is set to 'true'
    IF current_setting('sync.disable_trigger', true) = 'true' THEN
        -- Allow manual ID insertion during tests when trigger is disabled
        IF NEW.id IS NOT NULL THEN
            RETURN NEW;
        ELSE
            -- Generate a random UUID if ID is not provided
            NEW.id := uuid_generate_v4()::text;
            RETURN NEW;
        END IF;
    END IF;

    -- Check if ID is already provided by the INSERT statement
    IF NEW.id IS NOT NULL THEN
        RAISE EXCEPTION 'Synchrotron Trigger Error: Manual ID insertion is not allowed for table %. ID must be generated by the system. Provided ID: %', TG_TABLE_NAME, NEW.id;
    END IF;

    -- 1. Get context from LOCAL settings (set by SyncService)
    -- Use 'true' in current_setting to indicate missing setting is not an error, handle null below
    v_action_record_id := current_setting('sync.current_action_record_id', true);
    
    -- Handle potential JSON parsing issues with collision map
    BEGIN
        -- Try to parse the collision map as JSONB
        v_collision_map := current_setting('sync.collision_map', true)::jsonb;
    EXCEPTION WHEN OTHERS THEN
        -- If parsing fails, initialize with empty object
        v_collision_map := '{}'::jsonb;
        RAISE NOTICE 'Failed to parse collision map from settings, using empty map instead';
    END;

    -- Error if action_record_id is missing (should be set by SyncService)
    IF v_action_record_id IS NULL THEN
        RAISE EXCEPTION 'Synchrotron Trigger Error: sync.current_action_record_id not set for deterministic ID generation.';
    END IF;

    -- 2. Generate stable string representation of NEW row content (excluding 'id')
    -- Convert row to jsonb, remove 'id', convert back to text.
    -- Relying on jsonb key order for now, may need refinement if unstable across environments.
    BEGIN
        v_record_jsonb := to_jsonb(NEW);
    EXCEPTION WHEN others THEN
        DECLARE
            row_text text := '';
            col_record record;
        BEGIN
            -- Build text representation of row
            FOR col_record IN 
                SELECT a.attname 
                FROM pg_attribute a 
                WHERE a.attrelid = TG_RELID 
                AND a.attnum > 0 
                AND NOT a.attisdropped
            LOOP
                EXECUTE format('SELECT $1.%I::text', col_record.attname) 
                USING NEW INTO v_content_string;
                row_text := row_text || col_record.attname || ': ' || COALESCE(v_content_string, 'NULL') || E'\n';
            END LOOP;
            
            RAISE EXCEPTION 'Synchrotron Trigger Error: Failed to convert row to JSONB. Table: %, Row data:\n%', 
                            TG_TABLE_NAME, row_text;
        END;
    END;
    
    v_content_string := (v_record_jsonb - 'id')::text; -- Exclude ID from hash input

    -- 3. Calculate content hash
    v_content_hash := md5(v_content_string);

    -- 4. Check collision map for this specific content hash
    v_counter := (v_collision_map->>v_content_hash)::int;

    IF v_counter IS NULL THEN
        -- First time seeing this content hash in this action
        v_counter := 0;
        -- Use content hash directly for first occurrence to ensure consistency
        v_name_string := v_content_hash;
        -- Update map for next time, store counter as integer (start count at 1 for next collision)
        v_collision_map := jsonb_set(v_collision_map, ARRAY[v_content_hash], to_jsonb(1), true);
    ELSE
        -- Collision detected, append counter to the hash
        v_name_string := v_content_hash || '_' || v_counter::text; -- Append current counter
        -- Increment counter in map for next collision
        v_collision_map := jsonb_set(v_collision_map, ARRAY[v_content_hash], to_jsonb(v_counter + 1), true);
    END IF;

    -- 5. Generate UUIDv5 using action_id as namespace and name_string
    -- Ensure action_record_id is a valid UUID format for the namespace argument
    BEGIN
        -- Check if action_record_id is a valid UUID string
        IF v_action_record_id IS NULL OR v_action_record_id = '' THEN
            -- Use a default namespace UUID if action_record_id is missing
            v_new_id := uuid_generate_v5('00000000-0000-0000-0000-000000000000'::uuid, v_name_string);
            RAISE NOTICE 'Using default namespace UUID due to missing action_record_id';
        ELSE
            -- Try to convert action_record_id to UUID
            BEGIN
                v_new_id := uuid_generate_v5(uuid(v_action_record_id), v_name_string);
            EXCEPTION WHEN invalid_text_representation THEN
                -- If conversion fails, use a deterministic fallback based on the text value
                v_new_id := uuid_generate_v5('00000000-0000-0000-0000-000000000000'::uuid, v_action_record_id || ':' || v_name_string);
                RAISE NOTICE 'Using fallback UUID generation for invalid action_record_id: %', v_action_record_id;
            END;
        END IF;
    END;

    -- 6. Assign the generated ID to the NEW record
    -- Assuming ID column is TEXT, adjust if it's UUID type
    NEW.id := v_new_id::text;

    -- 7. Update the collision map in the LOCAL setting for the next trigger invocation
    PERFORM set_config('sync.collision_map', v_collision_map::text, true);

    -- 8. Return the modified NEW record
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to apply the deterministic ID trigger to a given table
CREATE OR REPLACE FUNCTION create_deterministic_id_trigger(p_table_name TEXT) RETURNS VOID AS $$
DECLARE
    trigger_exists BOOLEAN;
BEGIN
    -- Check if the trigger already exists
    SELECT EXISTS (
        SELECT 1
        FROM pg_trigger
        WHERE tgname = '01_generate_deterministic_id_trigger' -- Ensure consistent naming
        AND tgrelid = (p_table_name::regclass)::oid
    ) INTO trigger_exists;

    -- If trigger doesn't exist, add it
    IF NOT trigger_exists THEN
        EXECUTE format('
            CREATE TRIGGER "01_generate_deterministic_id_trigger"
            BEFORE INSERT ON %I
            FOR EACH ROW
            EXECUTE FUNCTION generate_deterministic_id();
        ', p_table_name);
        RAISE NOTICE 'Created 01_generate_deterministic_id_trigger on table %', p_table_name;
    ELSE
        RAISE NOTICE '01_generate_deterministic_id_trigger already exists on table %', p_table_name;
    END IF;
END;
$$ LANGUAGE plpgsql;
